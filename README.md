# CodeBetter

# LeetCode

## 1. 
## 2. 
## 3. 
## 4. 
## 5. 
## 6. 
## 7. 
## 8. 
## 9. 
## 10. 
## 11. 
## 12. 
## 13. 
## 14. 
## 15. 
## 16. 
## 17. 
## 18. 
## 19. 
## 20. 
## 21. 
## 22. 
## 23. 
## 24. 
## 25. 
## 26. 
## 27. 
## 28. 
## 29. 
## 30. 
## 31. 
## 32. 
## 33. 
## 34. 
## 35. 
## 36. 
## 37. 
## 38. 
## 39. 
## 40. 
## 41. 
## 42. 
## 43. 
## 44. 
## 45. 
## 46. 
## 47. 
## 48. 
## 49. 
## 50. 
## 51. 
## 52. 
## 53. 
## 54. 
## 55. 
## 56. 
## 57. 
## 58. 
## 59. 
## 60. 
## 61. 
## 62. 
## 63. 
## 64. 
## 65. 
## 66. 
## 67. 
## 68. 
## 69. 
## 70. 
## 71. 
## 72. 
## 73. 
## 74. 
## 75. 
## 76. 
## 77. 
## 78. 
## 79. 
## 80. 
## 81. 
## 82. 
## 83. 
## 84. 
## 85. 
## 86. 
## 87. 
## 88. 
## 89. 
## 90. 
## 91. 
## 92. 
## 93. 
## 94. 
## 95. 
## 96. 
## 97. 
## 98. 
## 99. 
## 100. 
## 101. 
## 102. 
## 103. 
## 104. 
## 105. 
## 106. 
## 107. 
## 108. 
## 109. 
## 110. 
## 111. 
## 112. 
## 113. 
## 114. 
## 115. 
## 116. 
## 117. 
## 118. 
## 119. 
## 120. 
## 121. 
## 122. 
## 123. 
## 124. 
## 125. 
## 126. 
## 127. 
## 128. 
## 129. 
## 130. 
## 131. 
## 132. 
## 133. 
## 134. 
## 135. 
## 136. 
## 137. 
## 138. 
## 139. 
## 140. 
## 141. 
## 142. 
## 143. 
## 144. 
## 145. 
## 146. 
## 147. 
## 148. 
## 149. 
## 150. 
## 151. 
## 152. 
## 153. 
## 154. 
## 155. 
## 156. 
## 157. 
## 158. 
## 159. 
## 160. 
## 161. 
## 162. 
## 163. 
## 164. 
## 165. 
## 166. 
## 167. 
## 168. 
## 169. 
## 170. 
## 171. 
## 172. 
## 173. 
## 174. 
## 175. 
## 176. 
## 177. 
## 178. 
## 179. 
## 180. 
## 181. 
## 182. 
## 183. 
## 184. 
## 185. 
## 186. 
## 187. 
## 188. 
## 189. 
## 190. 
## 191. 
## 192. 
## 193. 
## 194. 
## 195. 
## 196. 
## 197. 
## 198. 
## 199. 
## 200. 
## 201. 
## 202. 
## 203. 
## 204. 
## 205. 
## 206. 
## 207. 
## 208. 
## 209. 
## 210. 
## 211. 
## 212. 
## 213. 
## 214. 
## 215. 
## 216. 
## 217. 
## 218. 
## 219. 
## 220. 
## 221. 
## 222. 
## 223. 
## 224. 
## 225. 
## 226. 
## 227. 
## 228. 
## 229. 
## 230. 
## 231. 
## 232. 
## 233. 
## 234. 
## 235. 
## 236. 
## 237. 
## 238. 
## 239. 
## 240. 
## 241. 
## 242. 
## 243. 
## 244. 
## 245. 
## 246. 
## 247. 
## 248. 
## 249. 
## 250. 
## 251. 
## 252. [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/description/)
### Intuition
Interval Scheduling problem. Determines if there are any overlapping intervals.
First sort the intervals in ascending order based on their start time. Then determine if there are any overlap by checking the head and tail of two adjacent intervals.

### WIL
#### Java Comparator within Sort Syntax
`Arrays./Collections.sort(array/list, new Comparator<T> () {public int compare (O o1, O o2)()});`

#### Compare to
Ascending order --> `i1 - i2`
Descending order --> `i2 - i1`
## 253. 
## 254. 
## 255. 
## 256. 
## 257. 
## 258. 
## 259. 
## 260. 
## 261. 
## 262. 
## 263. 
## 264. 
## 265. 
## 266. 
## 267. 
## 268. 
## 269. 
## 270. 
## 271. 
## 272. 
## 273. 
## 274. 
## 275. 
## 276. 
## 277. 
## 278. 
## 279. 
## 280. 
## 281. 
## 282. 
## 283. 
## 284. 
## 285. 
## 286. 
## 287. 
## 288. 
## 289. 
## 290. 
## 291. 
## 292. 
## 293. 
## 294. 
## 295. 
## 296. 
## 297. 
## 298. 
## 299. 
## 300. 
## 301. 
## 302. 
## 303. 
## 304. 
## 305. 
## 306. 
## 307. 
## 308. 
## 309. 
## 310. 
## 311. 
## 312. 
## 313. 
## 314. 
## 315. 
## 316. 
## 317. 
## 318. 
## 319. 
## 320. 
## 321. 
## 322. 
## 323. 
## 324. 
## 325. 
## 326. 
## 327. 
## 328. 
## 329. 
## 330. 
## 331. 
## 332. 
## 333. 
## 334. 
## 335. 
## 336. 
## 337. 
## 338. 
## 339. 
## 340. 
## 341. 
## 342. 
## 343. 
## 344. 
## 345. 
## 346. 
## 347. 
## 348. 
## 349. 
## 350. 
## 351. 
## 352. 
## 353. 
## 354. 
## 355. 
## 356. 
## 357. 
## 358. 
## 359. 
## 360. 
## 361. 
## 362. 
## 363. 
## 364. 
## 365. 
## 366. 
## 367. 
## 368. 
## 369. 
## 370. 
## 371. 
## 372. 
## 373. 
## 374. 
## 375. 
## 376. 
## 377. 
## 378. 
## 379. 
## 380. 
## 381. 
## 382. 
## 383. 
## 384. 
## 385. 
## 386. 
## 387. 
## 388. 
## 389. 
## 390. 
## 391. 
## 392. 
## 393. 
## 394. 
## 395. 
## 396. 
## 397. 
## 398. 
## 399. 
## 400. 
## 401. 
## 402. 
## 403. 
## 404. 
## 405. 
## 406. 
## 407. 
## 408. 
## 409. 
## 410. 
## 411. 
## 412. 
## 413. 
## 414. 
## 415. 
## 416. 
## 417. 
## 418. 
## 419. 
## 420. 
## 421. 
## 422. 
## 423. 
## 424. 
## 425. 
## 426. 
## 427. 
## 428. 
## 429. 
## 430. 
## 431. 
## 432. 
## 433. 
## 434. 
## 435. 
## 436. 
## 437. 
## 438. 
## 439. 
## 440. 
## 441. 
## 442. 
## 443. 
## 444. 
## 445. 
## 446. 
## 447. 
## 448. 
## 449. 
## 450. 
## 451. 
## 452. 
## 453. 
## 454. 
## 455. 
## 456. 
## 457. 
## 458. 
## 459. 
## 460. 
## 461. [Hamming Distance](https://leetcode.com/problems/hamming-distance/description/)
### Intuition
Just use bitCount on the XOR result.
## 462. 
## 463. 
## 464. 
## 465. 
## 466. 
## 467. 
## 468. 
## 469. 
## 470. 
## 471. 
## 472. 
## 473. 
## 474. 
## 475. 
## 476. 
## 477. 
## 478. 
## 479. 
## 480. 
## 481. 
## 482. 
## 483. 
## 484. 
## 485. 
## 486. 
## 487. 
## 488. 
## 489. 
## 490. 
## 491. 
## 492. 
## 493. 
## 494. 
## 495. 
## 496. 
## 497. 
## 498. 
## 499. 
## 500. 
## 501. 
## 502. 
## 503. 
## 504. 
## 505. 
## 506. 
## 507. 
## 508. 
## 509. 
## 510. 
## 511. 
## 512. 
## 513. 
## 514. 
## 515. 
## 516. 
## 517. 
## 518. 
## 519. 
## 520. 
## 521. 
## 522. 
## 523. 
## 524. 
## 525. 
## 526. 
## 527. 
## 528. 
## 529. 
## 530. 
## 531. 
## 532. 
## 533. 
## 534. 
## 535. 
## 536. 
## 537. 
## 538. 
## 539. 
## 540. 
## 541. 
## 542. 
## 543. 
## 544. 
## 545. 
## 546. 
## 547. 
## 548. 
## 549. 
## 550. 
## 551. 
## 552. 
## 553. 
## 554. 
## 555. 
## 556. 
## 557. 
## 558. 
## 559. 
## 560. 
## 561. 
## 562. 
## 563. 
## 564. 
## 565. 
## 566. 
## 567. 
## 568. 
## 569. 
## 570. 
## 571. 
## 572. 
## 573. 
## 574. 
## 575. 
## 576. 
## 577. 
## 578. 
## 579. 
## 580. 
## 581. 
## 582. 
## 583. 
## 584. 
## 585. 
## 586. 
## 587. 
## 588. 
## 589. 
## 590. 
## 591. 
## 592. 
## 593. 
## 594. 
## 595. 
## 596. 
## 597. 
## 598. 
## 599. 
## 600. 
## 601. 
## 602. 
## 603. 
## 604. 
## 605. 
## 606. 
## 607. 
## 608. 
## 609. 
## 610. 
## 611. 
## 612. 
## 613. 
## 614. 
## 615. 
## 616. 
## 617. [Merge Two Binary Tree](https://leetcode.com/problems/merge-two-binary-trees/description/)
### Intuition
Traverse through the tree. If both nodes are null, the resulting node is null. If either of them is not null, then we create a new TreeNode with the value equal to their sum. Then we use recursion to repeat the process on the children of the current node.
## 618. 
## 619. 
## 620. 
## 621. 
## 622. 
## 623. 
## 624. 
## 625. 
## 626. 
## 627. 
## 628. 
## 629. 
## 630. 
## 631. 
## 632. 
## 633. 
## 634. 
## 635. 
## 636. 
## 637. 
## 638. 
## 639. 
## 640. 
## 641. 
## 642. 
## 643. 
## 644. 
## 645. 
## 646. 
## 647. 
## 648. 
## 649. 
## 650. 
## 651. 
## 652. 
## 653. 
## 654. 
## 655. 
## 656. 
## 657. [Judge Route Circle](https://leetcode.com/problems/judge-route-circle/description/)
### Intuition
Just do it by simulation.
## 658. 
## 659. 
## 660. 
## 661. 
## 662. 
## 663. 
## 664. 
## 665. 
## 666. 
## 667. 
## 668. 
## 669. 
## 670. 
## 671. 
## 672. 
## 673. 
## 674. 
## 675. 
## 676. 
## 677. 
## 678. 
## 679. 
## 680. 
## 681. 
## 682. 
## 683. 
## 684. 
## 685. 
## 686. 
## 687. 
## 688. 
## 689. 
## 690. 
## 691. 
## 692. 
## 693. 
## 694. 
## 695. 
## 696. [Count Binary Substrings](https://leetcode.com/problems/count-binary-substrings/description/)
### Intuition
Each time we encounter a different digit, we keep the length of the previous segment and increment the result for every digit forward until 1) the length of the current segment exceeds that of the previous segment. or 2) we encounter the next different digit

## 697. 
## 698. 
## 699. 
## 700. 
## 701. 
## 702. 
## 703. 
## 704. 
## 705. 
## 706. 
## 707. 
## 708. 
## 709. 
## 710. 
## 711. 
## 712. 
## 713. 
## 714. 
## 715. 
## 716. 
## 717. 
## 718. 
## 719. 
## 720. 
## 721. 
## 722. 
## 723. 
## 724. 
## 725. 
## 726. 
## 727. 
## 728. [Self Dividing Numbers](https://leetcode.com/problems/self-dividing-numbers/description/)
### Intuition
For each number, check if every digit can divide the number without remainder.
Pretty self-explanatory problem.

## 729. 
## 730. 
## 731. 
## 732. 
## 733. 
## 734. 
## 735. 
## 736. 
## 737. 
## 738. 
## 739. 
## 740. 
## 741. 
## 742. 
## 743. 
## 744. 
## 745. 
## 746. 
## 747. 
## 748. 
## 749. 
## 750. 
## 751. 
## 752. 
## 753. 
## 754. 
## 755. 
## 756. 
## 757. 
## 758. 
## 759. 
## 760. [Find Anagram Mappings](https://leetcode.com/problems/find-anagram-mappings/description/)
### Intuition
Very straightforward using HashMap.
## 761. 
## 762. 
## 763. 
## 764. 
## 765. 
## 766. 
## 767. 
## 768. 
## 769. 
## 770. 
## 771. [Jewels and Stones](https://leetcode.com/problems/jewels-and-stones/description/)
### Intuition
Several ways to approach this problem, each with different space and time complexity.

#### String replaceAll
```
public int numJewelsInStones(String J, String S) {
    return S.replaceAll("[^" + J + "]", "").length();
}
```
Can be expensive, but a very interesting solution using regular expression.<br>
It removes all the characters that is not a jewel in the stones string. We are left with jewels and just need to find the length of the remaining string.

#### Brute force
Time: O(JS)
Space: O(J + S)
```java
    public int numJewelsInStones(String J, String S) {
        // Brute force approach
        int result = 0;
        for (char chJ : J.toCharArray())
            for (char chS : S.toCharArray())
                if (chJ == chS)
                    result++;
        return result;
    }
```

#### Store the Jewels
Time: O(J+S)
Space: O(1)
The idea is to store the jewels in an array of length 58, which is 'z' - 'A'. And check for each character in stone array if it is a jewel.<br>
A HashSet should work too.
```java
public int numJewelsInStones(String J, String S) {
        int res = 0;
        Set setJ = new HashSet();
        for (char j: J.toCharArray()) setJ.add(j);
        for (char s: S.toCharArray()) if (setJ.contains(s)) res++;
        return res;
    }
```
## 772. 
## 773. 
## 774. 
## 775. 
## 776. 
## 777. 
## 778. 
## 779. 
## 780. 
## 781. 
## 782. 
## 783. 
## 784. 
## 785. 
## 786. 
## 787. 
## 788. 
## 789. 
## 790. 
## 791. 
## 792. 
## 793. 
## 794. 
## 795. 
## 796. 
## 797. 
## 798. 
## 799. 
## 800. 
## 801. 
## 802. 
## 803. 
## 804. [Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/description/)
### Intuition
Use a HashSet to store the patterns we've seen. Check the size in the end to get the number of unique morse code words.
## 805. 
## 806. 
## 807. 
## 808. 
## 809. 
## 810. 
## 811. 
## 812. 
## 813. 
## 814. 
## 815. 
## 816. 
## 817. 
## 818. 
## 819. 
## 820. 
## 821. 
## 822. 
## 823. 
## 824. 
## 825. 
## 826. 
## 827. 
## 828. 
## 829. 
## 830. 
## 831. 
## 832. [Flipping an Image](https://leetcode.com/problems/flipping-an-image/description/)
### Intuition
Just do in place element swapping. Use (C+1) / 2 to iterate over all indexes i in the first half of the row, inlcuding the center.

### WIL
Standard element swapping
```
int tmp = A;
A = B;
B = tmp;
```
Use XOR to flip bits
```
1^1 = 0
0^1 = 1
```
Do in place swap whenever possible for better space complexity.

## 833. 
## 834. 
## 835. 
## 836. 
## 837. 
## 838. 
## 839. 
## 840. 
## 841. 
## 842. 
## 843. 
## 844. 
## 845. 
## 846. 
## 847. 
## 848. 
## 849. 
## 850. 
## 851. 
## 852. [Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)
### Intuition
Binary Search
## 853. 
## 854. 
## 855. 
## 856. 
## 857. 
## 858. 
## 859. 
## 860. [Lemonade Change](https://leetcode.com/problems/lemonade-change/description/)
### Intuition
Keep track of the change (5 and 10 dollar bills). Subtract the number of change when encountered a bill with 10 or 20. Greedy solution in the sense that we would prefer to give out a $10 change first when receiving a bill of 20.

## 861. 
## 862. 
## 863. 
## 864. 
## 865. 
## 866. 
## 867. 
## 868. 
## 869. 
## 870. 
## 871. 
## 872. 
## 873. 
## 874. 
## 875. 
## 876. 
## 877. 
## 878. 
## 879. 
## 880. 
## 881. 
## 882. 
## 883. 
## 884. 
## 885. 
## 886. 
## 887. 
## 888. 
## 889. 
## 890. 
## 891. 
## 892. 
## 893. 
## 894. 
## 895. 
## 896. 
## 897. 
## 898. 
## 899. 

